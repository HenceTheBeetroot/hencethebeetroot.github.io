export default class DataObject {
  /**
   * Constructs a new DataObject. Requires the following:
   * 
   * .setDevice(GPUDevice) <- generated by requestDevice()
   * 
   * .setCanvasFormat(canvasFormat) <- generated by getPreferredCanvasFormat()
   * 
   * .setShaderPath(string) <- string should be path to shader file
   * 
   * .startDataBind(any[]) <- begins a data bind with the given array
   * 
   * .setDynamic(boolean) <- whether the data should be recognized by COMPUTE
   * 
   * .setDrawing(boolean) <- whether the data should be recognized by RENDER
   * 
   * .commitDataBind() <- commits the data, ending the current data bind
   * 
   * ONCE THIS IS DONE, use renderer.appendToSceneObject(this) to initialize.
   * 
   * @param {string} name 
   */

  constructor(name) {
    this.name = name
    this.device = null;
    this.canvasFormat = null;
    this.shaderPath = null;
    this.data = [];
    this.namedData = {};
    this.bindingData = null;
    this.offsets = [0]
    this.offset = new Uint32Array([0])
  }

  /**
   * @param {GPUDevice} device genereted by requestDevice()
   * @returns self
   */
  setDevice(device) {
    this.device = device;
    return this;
   }
   /**
    * @param {string} canvasFormat rgba8unorm or bgra8unorm; generated by getPreferredCanvasFormat()
    * @returns self
    */
  setCanvasFormat(canvasFormat) {
    this.canvasFormat = canvasFormat;
    return this;
   }
   /**
    * @param {string} shaderPath
    * @returns self
    */
  setShaderPath(shaderPath) {
    this.shaderPath = shaderPath;
    return this;
   }
  /**
   * @param {Array} object
   * @returns self
   */
  startDataBind(object) {
    this.bindingData = { data: object };
    return this;
  }
  /**
   * @param {boolean} status
   * @returns self
   */
  setDynamic(status) {
    this.bindingData.dynamic = status;
    return this;
   }
   /**
    * @param {boolean} status
    * @returns self
    */
  setDrawing(status) {
    this.bindingData.drawing = status;
    return this;
   }
   /**
    * @returns self, unless an error is thrown
    */
  commitDataBind() {
    if (this.bindingData != null && "data" in this.bindingData && "dynamic" in this.bindingData && "drawing" in this.bindingData) {
      if (this.bindingData.data.length % 2 == 1) {
        this.bindingData.data.push(null);
      }
      if (Array.isArray(this.bindingData.data)) {
        this.data.push(this.bindingData);
      } else {
        this.namedData = { ...this.namedData, ...Object.fromEntries(Object.keys(this.bindingData.data).map((val, idx) => [val, this.data.length + idx])) };
        this.data.push({ ...this.bindingData, ...{ data: Object.values(this.bindingData.data).flat() } });
      }
      this.bindingData = null;
      return this;
    } else {
       console.error("Attempted to commit data bind before data was fully initialized!");
       throw new Error();
    }
  }
  printData() {
    console.log(this.data);
    return this;
  }
  
  async init() {
    if (
      this.device === null ||
      this.canvasFormat === null ||
      this.shaderPath === null ||
      this.data === null
    ) {
      console.error(`Attempted to initialize DataObject "${this.name}" before defining all values!` +
        "\nDevice: " + this.device +
        "\nCanvas Format: " + this.canvasFormat +
        "\nShader Path: " + this.shaderPath +
        "\nData Array: " + this.data
      );
    }
    
    this.data.forEach(
      (obj) => {
        obj.data = new Float32Array(obj.data);
        this.offsets.push(
          this.offsets[this.offsets.length - 1] + obj.data.length / 2
        );
      }
    );
    console.log(this.offsets);
    this.offsets = new Uint32Array(this.offsets);
    await this.createGeometry();
    await this.createShaders();
    await this.createRenderPipeline();
    await this.createComputePipeline();
    console.log(`Initialized DataObject "${this.name}"`, this);
  }
  
  loadShader(filename) {
    return new Promise((resolve, reject) => {
      const xhttp = new XMLHttpRequest();
      xhttp.open("GET", filename);
      xhttp.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0");
      xhttp.onload = function() {
        if (xhttp.readyState === XMLHttpRequest.DONE && xhttp.status === 200) {
          resolve(xhttp.responseText);
        }
        else {
          reject({
            status: xhttp.status,
            statusText: xhttp.statusText
          });
        }
      };
      xhttp.onerror = function () {
        reject({
          status: xhttp.status,
          statusText: xhttp.statusText
        });
      };
      xhttp.send();
    });
  }

  updateGeometry() {}
  
  async createGeometry() {
    console.log(this.offsets)
    this.offsetBuffer = this.device.createBuffer({
      label: "Offset Buffer",
      size: Uint32Array.BYTES_PER_ELEMENT,
      usage: GPUBufferUsage.COMPUTE | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX
    })

    this.device.queue.writeBuffer(this.offsetBuffer, 0, this.offset);

    const bufferData = new Float32Array(this.data.map((obj) => Array.from(obj.data)).flat())

    this.dataFlipFlopBuffer = [this.device.createBuffer({
        label: "Generic Data Flip-Flop Buffer A",
        size: bufferData.byteLength,
        usage: GPUBufferUsage.COMPUTE | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.UNIFORM
      }),
      this.device.createBuffer({
        label: "Generic Data Flip-Flop Buffer B",
        size: bufferData.byteLength,
        usage: GPUBufferUsage.COMPUTE | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.UNIFORM
      })];

    this.step = 0;
    this.device.queue.writeBuffer(this.dataFlipFlopBuffer[0], 0, bufferData);
  }
  
  async createShaders() {
    let shaderCode = await this.loadShader(this.shaderPath);

    this.shaderModule = this.device.createShaderModule({
      label: "Generic Data Shader",
      code: shaderCode,
    });
    
    this.bindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
        buffer: { type: "read-only-storage"} // Data input buffer
      }, {
        binding: 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: "storage"} // Data output buffer
      }]
    });

    this.offsetBindGroupLayout = this.device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
        buffer: { type: "read-only-storage"}
      }]})
    
    this.pipelineLayout = this.device.createPipelineLayout({
      label: "Generic Data Pipeline Layout",
      bindGroupLayouts: [ this.bindGroupLayout, this.offsetBindGroupLayout ],
    });
  }
  
  async createRenderPipeline() {
    this.vertexBufferLayout = {
      arrayStride: 8, // 2 floats * 4 bytes
      attributes: [{
        shaderLocation: 0,
        offset: 0,
        format: "float32x2"
      }]
    };

    this.renderPipeline = this.device.createRenderPipeline({
      label: "Generic Data Render Pipeline",
      layout: this.pipelineLayout,
      vertex: {
        module: this.shaderModule,         // the shader code
        entryPoint: "vertexMain",           // the shader function
        buffers: [this.vertexBufferLayout] // the binded buffer layout
      },
      fragment: {
        module: this.shaderModule,    // the shader code
        entryPoint: "fragmentMain",    // the shader function
        targets: [{
          format: this.canvasFormat   // the target canvas format
        }]
      },
      primitive: {                     // instead of drawing triangles
        topology: 'line-strip'         // draw line strip
      }
    });
    
    // create bind group to bind the uniform buffer
    this.bindGroups = [
      this.device.createBindGroup({
        label: "Collective Data Bind Group Unit A",
        layout: this.bindGroupLayout,
        entries: [{
          binding: 0,
          resource: { buffer: this.dataFlipFlopBuffer[0] }
        }, {
          binding: 1,
          resource: { buffer: this.dataFlipFlopBuffer[1] }
        }],
      }),
      this.device.createBindGroup({
        label: "Collective Data Bind Group Unit B",
        layout: this.bindGroupLayout,
        entries: [{
          binding: 0,
          resource: { buffer: this.dataFlipFlopBuffer[1] }
        }, {
          binding: 1,
          resource: { buffer: this.dataFlipFlopBuffer[0] }
        }],
      })
    ];
    this.offsetBindGroup = this.device.createBindGroup({
      label: "Offset Bind Group",
      layout: this.offsetBindGroupLayout,
      entries: [{
        binding: 0,
        resource: { buffer: this.offsetBuffer }
      }]
    });

  }
  
  render(pass) {
    // add to render pass to draw the object
    pass.setPipeline(this.renderPipeline);
    pass.setBindGroup(1, this.offsetBindGroup);
    pass.setVertexBuffer(0, this.dataFlipFlopBuffer[this.step]);
    pass.setBindGroup(0, this.bindGroups[this.step]);
    this.data.forEach((obj, idx) => {
      if (obj.drawing) {
        this.offset[0] = this.offsets[idx];
        this.device.queue.writeBuffer(this.offsetBuffer, 0, this.offset);
        pass.draw(obj.data.length / 2);
      }
    });
  }
  
  async createComputePipeline() {
    // Create a compute pipeline that updates the game state.
    this.computePipeline = this.device.createComputePipeline({
      label: "Generic Data Compute Pipeline",
      layout: this.pipelineLayout,
      compute: {
        module: this.shaderModule,
        entryPoint: "computeMain",
      }
    });
  }
  
  compute(pass) { 
    // add to compute pass
    pass.setPipeline(this.computePipeline);
    pass.setBindGroup(0, this.bindGroups[this.step]);
    pass.setBindGroup(1, this.offsetBindGroup);
    this.data.forEach((obj, idx) => {
      if (obj.dynamic) {
        this.offset[0] = this.offsets[idx];
        this.device.queue.writeBuffer(this.offsetBuffer, 0, this.offset);
        pass.dispatchWorkgroups(Math.ceil(obj.data.length / 256));
      }
    })
    this.step ++;
    this.step %= 2;
  }
}