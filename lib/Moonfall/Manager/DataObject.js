export default class DataObject {
  /**
   * Constructs a new DataObject. Requires the following:
   * 
   * .setDevice(GPUDevice) <- generated by requestDevice()
   * 
   * .setCanvasFormat(canvasFormat) <- generated by getPreferredCanvasFormat()
   * 
   * .setShaderPath(string) <- string should be path to shader file
   * 
   * .startDataBind(any[]) <- begins a data bind with the given array
   * 
   * .setWritable(boolean) <- does nothing right now but you gotta set it anyways just in case :D
   * 
   * .setDrawing(boolean) <- whether the data being bound represents an array of vertices that should be drawn to the screen
   * 
   * .commitDataBind() <- commits the data, ending the current data bind
   * 
   * ONCE THIS IS DONE, use renderer.appendToSceneObject(this) to initialize.
   * 
   * @param {string} name 
   */

  constructor(name) {
    this.name = name
    this.device = null;
    this.canvasFormat = null;
    this.shaderPath = null;
    this.data = [];

    this.bindingData = null;
  }

  /**
   * @param {GPUDevice} device genereted by requestDevice()
   * @returns self
   */
  setDevice(device) {
    this.device = device;
    return this;
   }
   /**
    * @param {string} canvasFormat rgba8unorm or bgra8unorm; generated by getPreferredCanvasFormat()
    * @returns self
    */
  setCanvasFormat(canvasFormat) {
    this.canvasFormat = canvasFormat;
    return this;
   }
   /**
    * @param {string} shaderPath
    * @returns self
    */
  setShaderPath(shaderPath) {
    this.shaderPath = shaderPath;
    return this;
   }
  /**
   * @param {Array} object
   * @returns self
   */
  startDataBind(object) {
    this.bindingData = { data: object };
    return this;
  }
  /**
   * @param {boolean} status
   * @returns self
   */
  setWritable(status) {
    this.bindingData.writable = status;
    return this;
   }
   /**
    * @param {boolean} status
    * @returns self
    */
  setDrawing(status) {
    this.bindingData.drawing = status;
    return this;
   }
   /**
    * @returns self, unless an error is thrown
    */
   commitDataBind() {
     if ("data" in this.bindingData && "writable" in this.bindingData && "drawing" in this.bindingData) {
       this.data.push(this.bindingData);
       this.bindingData = null;
       return this;
     } else {
       console.error("Attempted to commit data bind before data was fully initialized!");
       throw new Error();
     }
   }
  
  async init() {
    if (
      this.device === null ||
      this.canvasFormat === null ||
      this.shaderPath === null ||
      this.data === null
    ) {
      console.error(`Attempted to initialize DataObject "${this.name}" before defining all values!` +
        "\nDevice: " + this.device +
        "\nCanvas Format: " + this.canvasFormat +
        "\nShader Path: " + this.shaderPath +
        "\nData Array: " + this.data
      );
    }
    
    this.data.forEach((obj) => obj.data = new Float32Array(obj.data));
    await this.createGeometry();
    await this.createShaders();
    await this.createRenderPipeline();
    await this.createComputePipeline();
    console.log(`Initialized DataObject "${this.name}"`, this);
  }
  
  loadShader(filename) {
    return new Promise((resolve, reject) => {
      const xhttp = new XMLHttpRequest();
      xhttp.open("GET", filename);
      xhttp.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0");
      xhttp.onload = function() {
        if (xhttp.readyState === XMLHttpRequest.DONE && xhttp.status === 200) {
          resolve(xhttp.responseText);
        }
        else {
          reject({
            status: xhttp.status,
            statusText: xhttp.statusText
          });
        }
      };
      xhttp.onerror = function () {
        reject({
          status: xhttp.status,
          statusText: xhttp.statusText
        });
      };
      xhttp.send();
    });
  }

  updateGeometry() {}
  
  async createGeometry() {
    this.dataFlipFlopBuffer = this.data.map((obj, idx) => [
      this.device.createBuffer({
        label: "Generic Data Flip-Flop Unit " + idx + " A",
        size: obj.data.byteLength,
        usage: GPUBufferUsage.COMPUTE | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.UNIFORM
      }),
      this.device.createBuffer({
        label: "Generic Data Flip-Flop Unit " + idx + " B",
        size: obj.data.byteLength,
        usage: GPUBufferUsage.COMPUTE | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.UNIFORM
      })
    ]).flat();

    this.step = 0;
    this.data.forEach((obj, idx) => this.device.queue.writeBuffer(this.dataFlipFlopBuffer[this.step + idx * 2], 0, obj.data));
  }
  
  async createShaders() {
    let shaderCode = await this.loadShader(this.shaderPath);

    this.shaderModule = this.device.createShaderModule({
      label: "Generic Data Shader",
      code: shaderCode,
    });
    this.bindGroupLayout = this.device.createBindGroupLayout({
      entries: this.data.map((obj, idx) => [{
        binding: idx * 2,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
        buffer: { type: "read-only-storage"} // Data input buffer
      }, {
        binding: idx * 2 + 1,
        visibility: GPUShaderStage.COMPUTE,
        buffer: { type: "storage"} // Data output buffer
      }]).flat()
    });
    
    this.pipelineLayout = this.device.createPipelineLayout({
      label: "Generic Data Pipeline Layout",
      bindGroupLayouts: [ this.bindGroupLayout ],
    });
  }
  
  async createRenderPipeline() {
    this.vertexBufferLayout = {
      arrayStride: 8, // 2 floats * 4 bytes
      attributes: [{
        shaderLocation: 0,
        offset: 0,
        format: "float32x2"
      }]
    };

    this.renderPipeline = this.device.createRenderPipeline({
      label: "Generic Data Render Pipeline",
      layout: this.pipelineLayout,
      vertex: {
        module: this.shaderModule,         // the shader code
        entryPoint: "vertexMain",           // the shader function
        buffers: [this.vertexBufferLayout] // the binded buffer layout
      },
      fragment: {
        module: this.shaderModule,    // the shader code
        entryPoint: "fragmentMain",    // the shader function
        targets: [{
          format: this.canvasFormat   // the target canvas format
        }]
      },
      primitive: {                     // instead of drawing triangles
        topology: 'line-strip'         // draw line strip
      }
    }); 
    // create bind group to bind the uniform buffer
    this.bindGroups = [
      this.device.createBindGroup({
        label: "Collective Data Bind Group Unit A",
        layout: this.renderPipeline.getBindGroupLayout(0),
        entries: this.data.map((obj, idx) => [{
          binding: idx * 2,
          resource: { buffer: this.dataFlipFlopBuffer[idx * 2] }
        }, {
          binding: idx * 2 + 1,
          resource: { buffer: this.dataFlipFlopBuffer[idx * 2 + 1] }
        }]).flat(),
      }),
      this.device.createBindGroup({
        label: "Collective Data Bind Group Unit B",
        layout: this.renderPipeline.getBindGroupLayout(0),
        entries: this.data.map((obj, idx) => [{
          binding: idx * 2,
          resource: { buffer: this.dataFlipFlopBuffer[idx * 2 + 1] }
        }, {
          binding: idx * 2 + 1,
          resource: { buffer: this.dataFlipFlopBuffer[idx * 2] }
        }]).flat(),
      })
    ];
  }
  
  render(pass) {
    // add to render pass to draw the object
    pass.setPipeline(this.renderPipeline);                                      // which render pipeline to use

    this.satisfyPipelineLayout = this.device.createBuffer({
      size: 1,
      usage: GPUBufferUsage.VERTEX
    })

    pass.setVertexBuffer(7, this.satisfyPipelineLayout);
    this.data.forEach((obj, idx) => {
      pass.setVertexBuffer(0, this.dataFlipFlopBuffer[idx * 2 + this.step]); // how the buffer is binded
      pass.setBindGroup(idx * 2, this.bindGroups[this.step]); // bind the uniform buffer
      if (obj.drawing) {
        pass.draw(Math.floor(obj.data.length / 2));
      }
    });
  }
  
  async createComputePipeline() {
    // Create a compute pipeline that updates the game state.
    this.computePipeline = this.device.createComputePipeline({
      label: "Generic Data Compute Pipeline",
      layout: this.pipelineLayout,
      compute: {
        module: this.shaderModule,
        entryPoint: "computeMain",
      }
    });
  }
  
  compute(pass) { 
    // add to compute pass
    pass.setPipeline(this.computePipeline);
    this.data.forEach((obj, idx) => {
      pass.setBindGroup(idx * 2, this.bindGroups[this.step]);     // bind the uniform buffer
      pass.setBindGroup(idx * 2 + 1, this.bindGroups[1 - this.step]);     // bind the uniform buffer
      pass.dispatchWorkgroups(Math.ceil(obj.data.length / 256));
    })
    this.step ++;
    this.step %= 2;
  }
}